packageName: com.example.emsql
className: DaoCursorDyn
declare:
  idBool: long
  bool01: Bool?
  bool02: Bool?
  bool03: Bool?
  bool04: Bool?
  bool11: Bool
  bool12: Bool
  bool13: Bool
  bool14: Bool
  circ: int
  dtMin: date
  dtMax: date

  id: BigSerial
  fingerprint: CHAR
  fingerprintIssuer: CHAR?
  serial: NUMBER
  commonName: VARCHAR
  organization: VARCHAR?
  orgUnit: VARCHAR?
  cType: INT
  keyAlgo: VARCHAR
  keySize: INT
  sigAlgo: VARCHAR
  notBefore: TIMESTAMP
  notAfter: TIMESTAMP
  cdRevoke: INT?
  tsRevoke: TIMESTAMP?
  usagePad: INT
  vers: INT
  lastSerial: NUMBER
  now: TIMESTAMP
  rawData: VARCHAR
  page: INT
  ultimate: NUMBOOL
  cFingerprint: CHAR
  count: INT

  issuer.fingerprint: CHAR
  issuer.commonName: VARCHAR
  issuer.organization: VARCHAR?
  issuer.orgUnit: VARCHAR?
  issuer.notBefore: TIMESTAMP
  issuer.notAfter: TIMESTAMP
  issuer.keySize: INT
  issuer.keyAlgo: VARCHAR
  issuer.cType: INT
  issuer.serial: NUMBER
  issuer.cdRevoke: INT?

methods:
  - methodName: cursor01
    perform: !CursorForSelect
      mode: ip
      fetchSize: 250
      execSql: |
        select 
          bool01,
          bool11
        into
          :bool01,
          :bool11 
        from tbool

  - methodName: cursor02
    perform: !CursorForSelect
      mode: fp
      execSql: |
        select 
          bool01 - 1,
          bool11      -- sql comment
        into
          :bool01,
          :bool11 
        from tbool
        where bool02 = :bool02

  - methodName: certificateCursor
    perform: !CursorForSelectDyn
      input:              # optional
        reflect: false    # optional, default false
        delegate: false   # optional, default false
      output:             # optional
        reflect: false    # optional, default false
        delegate: false   # optional, default false
      timeout: 5          # (seconds) optional, default null (system default)
      fetchSize: 2048     # optional, default null (system default)
      mode: IP            # optional, default IP (Imperative), else FP (Functional)
      execSql: |
        select
          A.K_FINGERPRINT, C.K_FINGERPRINT_ISSUER, A.CNAME, A.CORG, A.CUNIT,
          C.NOT_BEFORE, C.NOT_AFTER, A.KEY_SIZE, A.KEY_ALGO, A.C_TYPE,
          C.SERIAL, C.CD_REVOKE, C.TS_REVOKE, C.USAGE_PAD, C.VERS,
          B.CNAME, B.CORG, B.CUNIT, 
          C.ULTIMATE, C.R_COUNT, C.C_FINGERPRINT
        into
          :fingerprint, :fingerprintIssuer, :commonName, :organization, :orgUnit,
          :notBefore, :notAfter, :keySize, :keyAlgo, :cType,
          :serial, :cdRevoke, :tsRevoke, :usagePad, :vers,
          :issuer.commonName, :issuer.organization, :issuer.orgUnit, 
          :ultimate, :count, :cFingerprint
        from C01_CERT_BASE A
        join C05_CERT_BIND C on C.K_FINGERPRINT = A.K_FINGERPRINT
        join C01_CERT_BASE B on B.K_FINGERPRINT = C.K_FINGERPRINT_ISSUER
        where A.C_TYPE = :cType
        order by C.NOT_AFTER asc, C.NOT_BEFORE desc, A.CNAME asc, A.K_FINGERPRINT asc , C.SERIAL
      optionalAnd:
        cnLike: A.CNAME LIKE :commonName
        isNotRevoked: C.CD_REVOKE is null
        isRevoked: C.CD_REVOKE is not null
        isNotExpired: C.NOT_BEFORE <= :now and C.NOT_AFTER >= :now
        isExpired: (:now < C.NOT_BEFORE or :now > C.NOT_AFTER)
        isRenewed: C.ULTIMATE = 0
        isNotRenewed: C.ULTIMATE = 1

  - methodName: cursor04
    perform: !CursorForSelectDyn
      fetchSize: 250
      mode: FP
      execSql: |
        select 
          bool01,
          bool11
        into
          :bool01,
          :bool11 
        from tbool
      optionalAnd:
        circuitEq: circ = :circ
        dtEmisRange: dt_Emis between :dtMin and :dtMax
        isRevoked: cd_revoke is null
        notExpired: B.NOT_BEFORE <= :now and :now <= B.NOT_AFTER
